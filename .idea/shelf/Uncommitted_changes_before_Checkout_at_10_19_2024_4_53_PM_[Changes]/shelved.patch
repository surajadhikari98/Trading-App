Index: pipeline-multithreaded-trade-processing/trade-processor-app/src/main/java/io/reactivestax/component/CsvTradeProcessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package io.reactivestax.component;\r\n\r\nimport com.rabbitmq.client.Channel;\r\nimport com.rabbitmq.client.DeliverCallback;\r\nimport io.reactivestax.contract.TradeProcessor;\r\nimport io.reactivestax.domain.Trade;\r\nimport io.reactivestax.exception.OptimisticLockingException;\r\nimport io.reactivestax.hikari.DataSource;\r\nimport io.reactivestax.infra.Infra;\r\nimport io.reactivestax.repository.TradePositionRepository;\r\nimport io.reactivestax.repository.CsvTradeProcessorRepository;\r\nimport io.reactivestax.utils.RabbitMQUtils;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.sql.*;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.CountDownLatch;\r\nimport java.util.concurrent.LinkedBlockingDeque;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\n\r\n@Slf4j\r\npublic class CsvTradeProcessor implements Runnable, TradeProcessor {\r\n    private final LinkedBlockingDeque<String> dequeue;\r\n    private final LinkedBlockingDeque<String> dlQueue = new LinkedBlockingDeque<>();\r\n    Map<String, Integer> retryMapper = new ConcurrentHashMap<>();\r\n    static AtomicInteger countSec = new AtomicInteger(0);\r\n\r\n\r\n    private final static String EXCHANGE_NAME = \"trades\";\r\n\r\n\r\n\r\n    public CsvTradeProcessor(LinkedBlockingDeque<String> dequeue) {\r\n        this.dequeue = dequeue;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        try {\r\n            processTrade();\r\n        } catch (Exception e) {\r\n            CsvTradeProcessor.log.info(\"trade processor:  {}\", e.getMessage());\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void processTrade() throws Exception {\r\n        CsvTradeProcessorRepository csvTradeProcessorRepository = new CsvTradeProcessorRepository(DataSource.getConnection());\r\n        Connection connection = DataSource.getConnection();\r\n\r\n        int partitionNumber = Infra.readFromApplicationPropertiesIntegerFormat(\"numberOfQueues\");\r\n        // Declare an exchange and queue, then bind them\r\n        Channel channel = RabbitMQUtils.createChannel();\r\n\r\n        // Declare an exchange and a single queue\r\n        channel.exchangeDeclare(EXCHANGE_NAME, \"direct\");\r\n\r\n        // Declare a single queue\r\n        String queueName = \"all_partitions_queue\";\r\n        channel.queueDeclare(queueName, true, false, false, null);\r\n\r\n        // Bind the queue to all three partitions\r\n        for (int i = 0; i < partitionNumber; i++) {\r\n            channel.queueBind(queueName, EXCHANGE_NAME, \"cc_partition_\" + i);\r\n        }\r\n\r\n        System.out.println(\" [*] Waiting for messages in '\" + queueName + \"'.\");\r\n\r\n        // Callback to handle the messages\r\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\r\n            String tradeId = new String(delivery.getBody(), \"UTF-8\");\r\n            System.out.println(\" [x] Received '\" + tradeId + \"' with routing key '\" + delivery.getEnvelope().getRoutingKey() + \"'\");\r\n            // Add logic here to process the transaction\r\n            String lookupQuery = \"SELECT payload FROM trade_payloads WHERE trade_id = ?\";\r\n            assert connection != null;\r\n            try (PreparedStatement stmt = connection.prepareStatement(lookupQuery)) {\r\n                stmt.setString(1, tradeId);\r\n                ResultSet resultSet = stmt.executeQuery();\r\n                if (resultSet.next()) {\r\n                    String payload = resultSet.getString(1);\r\n                    String[] payloads = payload.split(\",\");\r\n                    Trade trade = new Trade(payloads[0], payloads[1], payloads[2], payloads[3], payloads[4], Integer.parseInt(payloads[5]), Double.parseDouble(payloads[6]), Integer.parseInt(payloads[5]));\r\n                    CsvTradeProcessor.log.info(\"Result journal{}\", payload);\r\n//                    System.out.println(\"result journal\" +  payload);\r\n//                    if (!csvTradeProcessorRepository.lookUpSecurityByCUSIP(trade.getCusip())) {\r\n//                        log.warn(\"No security found....\");\r\n//                        System.out.println(\"no sec found\" + trade.getCusip() + dlQueue.size());\r\n//                        dlQueue.put(trade.getTradeIdentifier());\r\n//                        log.debug(\"times {} {}\", trade.getCusip(), countSec.incrementAndGet());\r\n//                        continue;\r\n//                    }\r\n                    csvTradeProcessorRepository.saveJournalEntry(trade);\r\n//                    if (tradeIdentifier == null) {\r\n//                        log.info(\"Optimistic locking occurred with trade {}\", trade.getPosition());\r\n//                        //logic for the retry count\r\n//                        if (mappingForRetryCount(trade) < 3) {\r\n//                            this.dequeue.addLast(trade.getTradeIdentifier());\r\n//                        } else {\r\n//                            dlQueue.put(trade.getTradeIdentifier());\r\n//                        }\r\n//                    } else {\r\n//                        log.info(\"Successful insertion for the trade with trade id: {}\", tradeIdentifier);\r\n//                    }\r\n                }\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n\r\n        };\r\n\r\n        // Start consuming messages\r\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> { });\r\n\r\n        // Use a CountDownLatch to wait indefinitely\r\n        CountDownLatch latch = new CountDownLatch(1);\r\n        latch.await(); // This will block the main thread forever until countDown() is called\r\n\r\n    }\r\n\r\n\r\n    // Process each position with optimistic locking and retry logic\r\n    //prior to version 1.2\r\n    public boolean processPosition(TradePositionRepository tradePositionRepository, Trade trade) throws SQLException, InterruptedException {\r\n        boolean isPositionUpdated = false;\r\n        try {\r\n            int version = tradePositionRepository.getCusipVersion(trade);\r\n            if (version == -1) {\r\n                isPositionUpdated = tradePositionRepository.insertPosition(trade);\r\n            } else {\r\n                isPositionUpdated = tradePositionRepository.updatePosition(trade, version);\r\n            }\r\n        } catch (OptimisticLockingException e) {\r\n            log.info(\"Optimistic locking occurred: {} with position: {}\", e.getMessage(), trade.getPosition());\r\n            //logic for the retry count\r\n            if (mappingForRetryCount(trade) < 3) {\r\n                this.dequeue.addLast(trade.getTradeIdentifier());\r\n            } else {\r\n                dlQueue.put(trade.getTradeIdentifier());\r\n            }\r\n        }\r\n        return isPositionUpdated;\r\n    }\r\n\r\n    public int mappingForRetryCount(Trade trade) {\r\n        int errorCount;\r\n        errorCount = retryMapper.putIfAbsent(trade.getTradeIdentifier(), 1);\r\n        if (retryMapper.get(trade.getTradeIdentifier()) != null) {\r\n            errorCount = retryMapper.compute(trade.getTradeIdentifier(), (k, i) -> i + 1);\r\n        }\r\n        return errorCount;\r\n    }\r\n\r\n    public int getDlQueueSize(){\r\n        return this.dlQueue.size();\r\n    }\r\n}\r\n
===================================================================
diff --git a/pipeline-multithreaded-trade-processing/trade-processor-app/src/main/java/io/reactivestax/component/CsvTradeProcessor.java b/pipeline-multithreaded-trade-processing/trade-processor-app/src/main/java/io/reactivestax/component/CsvTradeProcessor.java
--- a/pipeline-multithreaded-trade-processing/trade-processor-app/src/main/java/io/reactivestax/component/CsvTradeProcessor.java	(revision 10540d5a2ffccc46358d3eb6b88a028aa54591c6)
+++ b/pipeline-multithreaded-trade-processing/trade-processor-app/src/main/java/io/reactivestax/component/CsvTradeProcessor.java	(date 1728786243471)
@@ -116,7 +116,6 @@
         // Use a CountDownLatch to wait indefinitely
         CountDownLatch latch = new CountDownLatch(1);
         latch.await(); // This will block the main thread forever until countDown() is called
-
     }
 
 
